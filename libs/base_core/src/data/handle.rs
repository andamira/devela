// devela_base_core::data::handle
//
//! Defines [`define_handle!`] macro.
//

#[cfg(any(doc, test))]
define_handle! {
    #[doc = crate::_TAG_EXAMPLE!()]
    /// An example handle generated by [`define_handle!`].
    ///
    /// Demonstrates a minimal two-field handle using `usize` primitives.
    pub ExampleHandle<usize>
}

/// Defines a lightweight handle type.
///
/// A *handle* is a lightweight, copyable semantic reference that identifies
/// an entry within a managed collection, such as an arena, list, or graph.
///
/// Handles are plain data values â€” they contain only small scalar fields
/// (like offsets, lengths, or indices) and no lifetimes or ownership.
///
/// Handles form the connective tissue of the data layer,
/// bridging raw storage with higher-level structure.
///
/// # Examples
/// The following defines a simple arena handle type.
/// See also [`ExampleHandle`].
/// ```
/// # use devela_base_core::define_handle;
/// define_handle! {
///     /// A custom handle.
///     pub ArenaHandle<usize>
/// }
/// ```
#[cfg_attr(cargo_primary_package, doc(hidden))]
#[macro_export]
macro_rules! define_handle {
    // Point of entry, defines the names
    (
    $(#[$handle_attr:meta])*
    $vis:vis $Handle:ident<$T:ty> $(;)?
    ) => {
        $crate::define_handle![%handle $(#[$handle_attr])* $vis $Handle<$T>];
    };
    // calls the necessary arms in order.
    (%handle $(#[$handle_attr:meta])* $vis:vis $Handle:ident<$T:ty>) => { $crate::paste! {
        $crate::define_handle![%main
            $(#[$handle_attr])* $vis $Handle<$T>
        ];
        // #[cfg(test)]
        // $crate::define_handle![%tests $Handle, [<test_ $Handle>]];
    }};
    (%main $(#[$handle_attr:meta])* $vis:vis $Handle:ident<$T:ty>) => {
        $(#[$handle_attr])*
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        $vis struct $Handle {
            offset: $T,
            len: $T,
        }

        /// Fundamental const methods for creation and access.
        #[allow(dead_code)]
        impl $Handle {
            #[inline(always)]
            /// Creates a new handle from an `offset` and `len`.
            $vis const fn new(offset: $T, len: $T) -> Self {
                Self { offset, len }
            }

            #[inline(always)]
            /// Returns the length of the stored data.
            #[allow(clippy::len_without_is_empty)]
            $vis const fn len(self) -> $T { self.len }

            #[inline(always)]
            /// Returns the offset of the stored data.
            $vis const fn offset(self) -> $T { self.offset }
        }
    };
}
#[doc(inline)]
pub use define_handle;
